#!/usr/bin/env python3
#
# Bare bones python template for parsing command-line arguments

import argparse
import datetime
import sys
import time

import pspace


DEFAULT_TAIL_LINES = 20


def process_command_line(argv):
    """Process command line invocation arguments and switches.

    Args:
        argv: list of arguments, or `None` from ``sys.argv[1:]``.

    Returns:
        argparse.Namespace: named attributes of arguments and switches
    """
    #script_name = argv[0]
    argv = argv[1:]

    # initialize the parser object:
    parser = argparse.ArgumentParser(
            description="Utilities for creating and monitoring paperspace jobs.")
    subparsers = parser.add_subparsers(dest='pspace_cmd', help='sub-command help')

    # create
    parser_create = subparsers.add_parser('create', help='create a new job')
    parser_create.add_argument(
            '--command', action='store',
            help='What command to execute on remote machine.'
            )
    parser_create.add_argument(
            '--machineType', action='store',
            help='What type of remote machine to use.'
            )

    # tail (of job log file)
    parser_tail = subparsers.add_parser('tail', help='get the tail of a job\'s log')
    parser_tail.add_argument(
            '--job_id', action='store',
            help='ID of job to be checked.'
            )
    parser_tail.add_argument(
            '-l', '--last', action='store', type=int,
            help='Only show the last this many lines.'
            )
    parser_tail.add_argument(
            '-f', '--follow', action='store_true',
            help='Follow the log file until cancelled or PSEOF.'
            )
    parser_tail.add_argument(
            '-a', '--all', action='store_true',
            help='Show all lines of log file.'
            )

    # jobs
    parser_jobs = subparsers.add_parser('jobs', help='list jobs')
    parser_jobs.add_argument(
            '-s', '--status', action='store',
            help='Filter only jobs matching this status.'
            )
    parser_jobs.add_argument(
            '-l', '--last', action='store', type=int,
            help='Only list the last this many jobs matching.'
            )

    # status
    parser_status = subparsers.add_parser('status', help='get a job\'s status')
    parser_status.add_argument(
            '--job_id', action='store',
            help='ID of job to be checked.'
            )

    # getart
    parser_getart = subparsers.add_parser('getart', help='download artifact files from a job')
    parser_getart.add_argument(
            '--job_id', action='store',
            help='ID of job to fetch artifacts for.'
            )
    parser_getart.add_argument(
            '--datadir', action='store', default='data',
            help='Local data directory holding to put job data dir.'
            )

    args = parser.parse_args(argv)

    return args


def get_job_id(args, pspace_last):
    if args.job_id is not None:
        job_id = args.job_id
    else:
        try:
            job_id = pspace_last['job_info']['id']
        except KeyError:
            print("Can't determine job id.")
            exit(1)
    return job_id


def parse_jobinfo_dt(dt_str):
    """From dt string from job_info, return datetime in UTC
    """
    dt = datetime.datetime.strptime(
                dt_str[:-5], "%Y-%m-%dT%H:%M:%S"
                )
    return dt.replace(tzinfo=datetime.timezone.utc)


def command_status(args):
    pspace_last = pspace.get_last_info()
    job_id = get_job_id(args, pspace_last)

    job_info = pspace.get_job_info(job_id)
    pspace.save_last_info(job_info)

    print("Job: " + job_id)
    print("State: " + job_info['state'])

    if job_info.get('dtStarted', None) is not None:
        started_utc = parse_jobinfo_dt(job_info['dtStarted'])
        started_local = started_utc.astimezone()
        print("Started: " + started_local.strftime("%Y-%m-%d %I:%M:%S%p"))

    if job_info['state'] == "Stopped":
        # get finished datetime in local time zone
        finished_utc = parse_jobinfo_dt(job_info['dtFinished'])
        finished_local = finished_utc.astimezone()
        print("Finished: " + finished_local.strftime("%Y-%m-%d %I:%M:%S%p"))
        print("Duration: " + str(finished_utc - started_utc))
        print("Exit Code: {0}".format(job_info['exitCode']))
    else:
        print("Duration (to now): " + str(finished_utc - datetime.now(datetime.timezone.utc)))


def command_jobs(args):
    # all datetimes start with dt in job_info (e.g. dtCreated, dtFinished, etc.)
    job_list = pspace.jobs_list()


def command_tail(args):
    tail_lines = args.last or DEFAULT_TAIL_LINES
    if args.all:
        # tail_lines = 0 is special value that indicates show all lines
        tail_lines = 0

    pspace_last = pspace.get_last_info()
    job_id = get_job_id(args, pspace_last)

    line_start = 0
    if tail_lines != 0:
        try:
            last_tot_log_lines = pspace_last['pspace_info']['total_log_lines']
            line_start = max(0, last_tot_log_lines - tail_lines)
        except KeyError:
            pass

    job_info = pspace.get_job_info(job_id)

    # TODO: Getting state here and log lines later could result both being 
    #   out of sync
    print("Job: " + job_id)
    print("State: " + job_info['state'] + " "*10, end="", flush=True)
    if pspace.job_not_started(job_id, job_info) and args.follow:
        # waiting for job to start, updating state while we wait
        while pspace.job_not_started(job_id, job_info):
            time.sleep(5)
            last_state = job_info['state']
            job_info = pspace.get_job_info(job_id)
            if job_info['state'] != last_state:
                print("\r", end="", flush=True)
                print("State: " + job_info['state'] + " "*10, end="", flush=True)
    print("")

    # so we don't print log lines if the old status says something before Running
    if pspace.job_started(job_id, job_info):
        log_lines = pspace.get_log_lines(job_id, line_start=line_start)
        total_log_lines = line_start + len(log_lines)
        pspace.save_last_info(job_info, {'total_log_lines':total_log_lines})
        for line in log_lines[-tail_lines:]:
            print(line)

    if args.follow:
        end_time = None
        line_start = len(log_lines) + line_start
        last_log_line = log_lines[-1] if log_lines else ''
        while last_log_line != "PSEOF":
            time.sleep(5)
            log_lines = pspace.get_log_lines(job_id, line_start=line_start)
            line_start += len(log_lines)
            last_log_line = log_lines[-1] if log_lines else last_log_line
            for line in log_lines[-tail_lines:]:
                print(line)
            if end_time is not None:
                # end follow loop for timeout 20 seconds after job done
                if time.time() - end_time > 20:
                    break
            if pspace.job_done(job_id):
                end_time = time.time()


def command_create(args):
    override_args = vars(args)
    override_args.pop('pspace_cmd')
    job_config = pspace.get_config('create', override_args)

    print(job_config)

    job_info = pspace.jobs_create(**job_config)

    pspace.save_last_info(job_info)

    print("Job " + job_info['id'] + " created.")


def command_getart(args):
    pspace_last = pspace.get_last_info()
    job_id = get_job_id(args, pspace_last)
    local_data_dir = args.datadir

    pspace.get_artifacts(job_id, local_data_dir)
    pspace.save_log(job_id, local_data_dir)


def main(argv=None):
    args = process_command_line(argv)

    if args.pspace_cmd == 'create':
        command_create(args)
    elif args.pspace_cmd == 'tail':
        command_tail(args)
    elif args.pspace_cmd == 'status':
        command_status(args)
    elif args.pspace_cmd == 'jobs':
        command_jobs(args)
    elif args.pspace_cmd == 'getart':
        command_getart(args)

    return 0


if __name__ == "__main__":
    try:
        status = main(sys.argv)
    except KeyboardInterrupt:
        # Make a very clean exit (no debug info) if user breaks with Ctrl-C
        print("Stopped by Keyboard Interrupt", file=sys.stderr)
        # exit error code for Ctrl-C
        status = 130

    sys.exit(status)
