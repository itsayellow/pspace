#!/usr/bin/env python3
#
# Bare bones python template for parsing command-line arguments

import argparse
import sys

import pspace

def process_command_line(argv):
    """Process command line invocation arguments and switches.

    Args:
        argv: list of arguments, or `None` from ``sys.argv[1:]``.

    Returns:
        argparse.Namespace: named attributes of arguments and switches
    """
    #script_name = argv[0]
    argv = argv[1:]

    # initialize the parser object:
    parser = argparse.ArgumentParser(
            description="Utilities for submitting and monitoring paperspace jobs.")
    subparsers = parser.add_subparsers(dest='pspace_cmd', help='sub-command help')
   
    # submit
    parser_submit = subparsers.add_parser('submit', help='submit help')
    parser_submit.add_argument(
            '--command', action='store',
            help='What command to execute on remote machine.'
            )
    parser_submit.add_argument(
            '--machineType', action='store',
            help='What type of remote machine to use.'
            )
   
    # tail
    parser_tail = subparsers.add_parser('tail', help='tail help')
    parser_tail.add_argument(
            '--job_id', action='store',
            help='ID of job to be checked.'
            )

    # jobs
    parser_jobs = subparsers.add_parser('jobs', help='jobs help')
    parser_jobs.add_argument(
            '--status', action='store',
            help='Filter only jobs matching this status.'
            )
    parser_jobs.add_argument(
            '--last', action='store',
            help='Only list the last this many jobs matching.'
            )

    # status
    parser_status = subparsers.add_parser('status', help='status help')
    parser_status.add_argument(
            '--job_id', action='store',
            help='ID of job to be checked.'
            )

    args = parser.parse_args(argv)

    return args


def get_job_id(args, info):
    if args.job_id is not None:
        job_id = args.job_id
    else:
        try:
            job_id = info['job_info']['id']
        except KeyError:
            print("Can't determine job id.")
            exit(1)
    return job_id


def command_status(args):
    info = pspace.get_last_info()
    get_job_id(args, info)

    job_info = pspace.get_job_info(job_id)
    pspace.save_last_info(job_info)

    print("Job: " + job_id)
    print("State: " + job_info['state'])



def command_jobs(args):
    pass


def command_tail(args):
    TAIL_LINES = 20

    info = pspace.get_last_info()
    get_job_id(args, info)

    try:
        last_tot_log_lines = info['pspace_info']['total_log_lines']
        line_start = last_tot_log_lines - TAIL_LINES
    except KeyError:
        line_start = 0

    job_info = pspace.get_job_info(job_id)
    log_lines = pspace.get_log_lines(job_id, line_start=line_start)
    total_log_lines = line_start + len(log_lines)
    pspace.save_last_info(job_info, {'total_log_lines':total_log_lines})

    print("Job: " + job_id)
    print("State: " + job_info['state'])
    for line in log_lines[-TAIL_LINES:]:
        print(line)


def command_submit(args):
    override_args = vars(args)
    override_args.pop('pspace_cmd')
    job_config = pspace.get_config(override_args)

    print(job_config)

    job_info = pspace.jobs_create(**job_config)

    pspace.save_last_info(job_info)

    print("Job " + job_info['id'] + " submitted.")


def main(argv=None):
    args = process_command_line(argv)

    if args.pspace_cmd == 'submit':
        command_submit(args)
    elif args.pspace_cmd == 'tail':
        command_tail(args)
    elif args.pspace_cmd == 'status':
        command_status(args)
    elif args.pspace_cmd == 'jobs':
        command_jobs(args)
    
    return 0


if __name__ == "__main__":
    try:
        status = main(sys.argv)
    except KeyboardInterrupt:
        # Make a very clean exit (no debug info) if user breaks with Ctrl-C
        print("Stopped by Keyboard Interrupt", file=sys.stderr)
        # exit error code for Ctrl-C
        status = 130

    sys.exit(status)
